/*
 * units.h
 *
 * It contains the definition of all units. A unit is
 * a compositions of individual components, that might
 * has more complex control rules or the additionl data
 * input.
 *
 */

#ifndef UNITS_H
#define UNITS_H

#include <atomic>
#include <condition_variable>
#include <string>
#include <list>
#include <map>
#include <mutex>

// The following classes are defined in this header file:
class Substation;
class ControlUnit;
class MeasurementUnit;
class OpenSpacePVOrWind;

#include "global.h"
#include "components.h"
#include "optimization_unit_general.hpp"
#include "output.h"
#include "worker_threads.hpp"


/*!
 * This class represents the base class for all kind of units, i.e., Substation, ControlUnit and MeasurementUnit.
 * This template class is using the so-called Curiously Recurring Template Pattern (CRTP) technique.
 *
 * @tparam Derived The derived unit class.
 */
template<class Derived>
class BaseUnit {
    public:
        /*!
         * Even though not required, this default destructor is added for safety reasons.
         */
        ~BaseUnit() = default;

        /*!
         * @brief Initialize the number of instances for the derived class that must be known when simulation is started.
         *
         * This method forwards the call to @c Derived::InitializeStaticVariables().
         *
         * @param n  The number of units to initialize (e.g., number of substations or control units).
         */
        static void InitializeStaticVariables(unsigned long n) {
            Derived::InitializeStaticVariables(n);
        }

        /*!
         * @brief Clean up all instances and static variables of the derived class.
         *
         * This method forwards the call to @c Derived::VacuumInstancesAndStaticVariables().
         * Each derived class must implement this function, which should remove
         * all dynamically created instances and reset static variables (including
         * @c public_to_internal_id if appropriate).
         */
        static void VacuumInstancesAndStaticVariables() {
            Derived::VacuumInstancesAndStaticVariables();
        }
};


/*!
 * This class represents a substation.
 * One or more control units are connected to one instance of this class.
 */
class Substation : BaseUnit<Substation> {
    public:
        /*!
         * Instantiates a new substation object.
         * Returns false, if the ID is already defined.
         */
        static bool InstantiateNewSubstation(unsigned long public_id, std::string* name);
    private:
        Substation(unsigned long internal_id, unsigned long public_id, std::string* name);
    public:
        ~Substation();
        // getter methods
        unsigned long get_internal_id() const { return internal_id; } ///< Returns the internal ID of the substation
        unsigned long get_id()         const  { return public_id;   } ///< Returns the ID of the substation as defined in the system structure database
        const std::string * get_name() const { return name; } ///< Returns the name of the substation
        double get_station_load()       const { return station_load;    } ///< Returns the current load at the substation in kW
        double get_residential_load()   const { return resident_load;   } ///< Returns the current load at the substation in kW, generated by residential control units only
        double get_residential_demand() const { return resident_demand; } ///< Returns the demand of residential control units at this substation in kW
        double get_current_demand_no_BESS()    const { return total_demand;    } ///< Returns the current demand of all connected units **without considering the local generation OR the BESS**
        double get_current_BESS_demand()                 const { return total_BESS_demand;    } ///< Returns the current charging demand of all BESS in all connected units
        double get_current_PV_generation_total_kW()      const { return pv_gen_total_kW;      } ///< Returns the current generation (without consideration of self-consumption) in kW that is generated by all connected PV installations
        double get_current_BS_generation_total_kW()      const { return bs_gen_total_kW;      } ///< Returns the current generation (without consideration of self-consumption) in kW that is generated by all connected battery storage systems
        double get_current_CHP_generation_total_kW()     const { return chp_gen_total_kW;     } ///< Returns the current generation (without consideration of self-consumption) in kW that is generated by all connected CHPs
        double get_current_wind_generation_total_kW()    const { return wind_gen_total_kW;    } ///< Returns the current generation (without consideration of self-consumption) in kW that is generated by all connected wind turbines
        double get_current_unknown_generation_total_kW() const { return unknown_gen_total_kW; } ///< Returns the current generation (without consideration of self-consumption) in kW that is generated by unknown components or not attributable to any generation technology
        double get_current_PV_feedin_to_grid_kW()        const { return pv_gen_expo_kW;       } ///< Returns the current feed-in into the grid in kW that is generated by all connected PV installations
        double get_current_BS_feedin_to_grid_kW()        const { return bs_gen_expo_kW;       } ///< Returns the current feed-in into the grid in kW that is generated by all connected battery storage systems
        double get_current_CHP_feedin_to_grid_kW()       const { return chp_gen_expo_kW;      } ///< Returns the current feed-in into the grid in kW that is generated by all connected CHPs
        double get_current_wind_feedin_to_grid_kW()      const { return wind_gen_expo_kW;     } ///< Returns the current feed-in into the grid in kW that is generated by all connected wind turbines
        double get_current_unknown_feedin_to_grid_kW()   const { return unknown_gen_expo_kW;  } ///< Returns the current feed-in into the grid in kW that is generated by unknown components or not attributable to any generation technology
        // modifiers bevore simulation start
        void add_unit(ControlUnit* unit);
        // methods for simulation run
        void  calc_load();
        const std::list<ControlUnit*>* get_connected_units() { return connected_units; } ///< Return the list of connected units (as read only list)
        //
        // static functions
        // 1. Initializers and destructors
        static void InitializeStaticVariables(unsigned long n_substations);
        static void VacuumInstancesAndStaticVariables();
        // 2. getter functions
        static Substation* GetInstancePublicID(unsigned long public_id); ///< Returns the instance with a given public_id
        static Substation* GetInstanceInternalID(unsigned long internal_id) { return st__substation_list[internal_id]; } ///< Returns the instance with a given public_id
        static const std::vector<Substation*>& GetArrayOfInstances() { return st__substation_list; } ///< Returns the std::vector of all substation instances. The objects itself are mutable, but the vector is const.
        static size_t GetNumberOfInstances() {return st__n_substations;}
    private:
        // constant member variables (other languages might call this 'final')
        const unsigned long internal_id; ///< The internal ID, must be sequentially
        const unsigned long public_id; ///< The public ID as given in the system structure database
        const std::string *const name;
        // member variables that can change over time
        std::list<ControlUnit*>* connected_units;
        double station_load;    ///< Load of the station
        double resident_load;   ///< Load only of residential buildings
        double resident_demand; ///< Residential load, only demand
        double total_demand;   ///< The total demand excluding BESS, sum of all control unit demands
        double total_BESS_demand; ///< The total demand of BESS, sum of all control unit demands
        double pv_gen_total_kW;      ///< PV generation in kW at a single time step - without the consideration of self-consumption per unit
        double bs_gen_total_kW;      ///< battery storage feed-in (to the local CU balance) at a single time step - without the consideration of self-consumption per unit
        double chp_gen_total_kW;     ///< CHP power generation in kW at a single time step - without the consideration of self-consumption per unit
        double wind_gen_total_kW;    ///< Wind power generation in kW at a single time step - without the consideration of self-consumption per unit
        double unknown_gen_total_kW; ///< Power generation in kW at a single time step caused by not attributable or unknown generation technologies - without the consideration of self-consumption per unit
        double pv_gen_expo_kW;      ///< PV generation in kW at a single time step - only the sum per unit minus self-consumption
        double bs_gen_expo_kW;      ///< battery storage feed-in (to the grid) at a single time step - only the sum per unit minus self-consumption
        double chp_gen_expo_kW;     ///< CHP power generation in kW at a single time step - only the sum per unit minus self-consumption
        double wind_gen_expo_kW;    ///< Wind power generation in kW at a single time step - only the sum per unit minus self-consumption
        double unknown_gen_expo_kW; ///< Power generation in kW at a single time step caused by not attributable or unknown generation technologies - only the sum per unit minus self-consumption
        //
        // static list of substations
        //static bool st__substation_list_init;
        static unsigned long st__n_substations;
        //static unsigned long st__new_substation_position;
        static std::vector<Substation*> st__substation_list;
        static std::map<unsigned long, unsigned long> public_to_internal_id;
};


/*!
 * This class represents a control unit (i.e. a private house or a small company).
 * As the name suggests it is the place where a central control is located (if any, or a rulebased otherwise).
 * All simulatively added components are added in this control unit.
 * It holds a set (at least one) of measurement units.
 */
class ControlUnit : BaseUnit<ControlUnit> {
    public:
        /*!
         * Instantiates a new control unit.
         * Returns false, if the unitID is already defined.
         */
        static bool InstantiateNewControlUnit(unsigned long unitID, unsigned long substation_id, unsigned long locationID, bool residential, unsigned int n_flats);
    private:
        /**
         * Constructs a new control unit.
         * @param internalID: The internal ID of the new unit. MUST be sequential and unique.
         * @param publicID: The ID of the unit as given in the system structure database.
         * @param substation_id: The ID of the substation as given in the system structure database.
         * @param locationID: The ID of the location where the control unit will be.
         * @param residential: True, if it is a representation of a residential building.
         * @param n_flats: The number of (residential) flats / apartments inside the represented building.
         */
        ControlUnit(unsigned long internalID, unsigned long publicID, unsigned long substation_id, unsigned long locationID, bool residential, unsigned int n_flats);
    public:
        ~ControlUnit();
        void add_unit(MeasurementUnit* unit);
        bool has_electricity_demand();
        bool has_pv();
        bool has_bs();
        bool has_hp();
        bool has_cs(); ///< Checks, if the unit has an EV charging station connected (in data or simulated)
        bool has_chp();
        bool has_wind();
        bool has_bs_sim_added();
        bool is_expandable_with_pv(); ///< Is a simulated PV installation addable (yes, if geodata is available). This function uses caching.
        bool is_expandable_with_hp(); ///< Is a simulated heat pump addable (yes, if geodata or gas consumption data is available). This function uses caching.
        bool is_residential() { return residential; } ///< Is this unit a residential unit?
        bool heat_demand_given_in_data(); ///< Returns true, if the heat demand for this location is given in the input data
        int  get_exp_combi_bit_repr();
        int  get_exp_combi_bit_repr_from_MUs();
        int  get_exp_combi_bit_repr_sim_added();
        double get_current_load_vSMeter_kW() { return current_load_vSM_kW; }
        double get_current_demand_wo_BS_or_gen_kW()    const { return current_total_consumption_kW; } ///< Returns the current local demand of all components **excluding the BESS** and also not considering the local generation from PV, wind, the BESS itselfe or the CHP
        double get_current_BS_demand_kW()              const; ///< Returns the current BESS (charging) demand in kW
        double get_current_PV_generation_kW()          const; ///< Returns the current local PV generation (regardless of self-consumption), always greater or equal to ControlUnit::get_current_PV_feedin_to_grid_kW()
        double get_current_BS_generation_kW()          const; ///< Returns the current local BS generation (regardless of self-consumption), always greater or equal to ControlUnit::get_current_PV_feedin_to_grid_kW()
        double get_current_CHP_generation_kW()         const; ///< Returns the current local CHP generation (regardless of self-consumption), always greater or equal to ControlUnit::get_current_PV_feedin_to_grid_kW()
        double get_current_wind_generation_kW()        const; ///< Returns the current local wind generation (regardless of self-consumption), always greater or equal to ControlUnit::get_current_PV_feedin_to_grid_kW()
        double get_current_unknown_generation_kW()     const; ///< Returns the current local generation that cannot be attributed to any generation technology (regardless of self-consumption), always greater or equal to ControlUnit::get_current_PV_feedin_to_grid_kW()
        double get_current_PV_feedin_to_grid_kW()      const { return current_PV_feedin_to_grid_kW;     } ///< Returns the current feed-in into the grid in kW that is generated by a PV installation
        double get_current_BS_feedin_to_grid_kW()      const { return current_BS_feedin_to_grid_kW;     } ///< Returns the current feed-in into the grid in kW that is generated by a battery storage system
        double get_current_CHP_feedin_to_grid_kW()     const { return current_CHP_feedin_to_grid_kW;    } ///< Returns the current feed-in into the grid in kW that is generated by a CHP
        double get_current_wind_feedin_to_grid_kW()    const { return current_wind_feedin_to_grid_kW;   } ///< Returns the current feed-in into the grid in kW that is generated by a wind turbine
        double get_current_unknown_feedin_to_grid_kW() const { return current_unknown_feedin_to_grid_kW;} ///< Returns the current feed-in into the grid in kW that is generated by unknown components or not attributable to any generation technology
        size_t get_n_MUs()     { return connected_units->size(); } // returns the number of MUs, that are connected to the given control unit
        size_t get_internal_id() const { return internal_id; }   ///< Returns the (consecutive) internal ID of the control unit
        size_t get_unitID()      const { return unitID; }        ///< returns the unit ID of this control unit as given in the system structure database
        size_t get_location_id() const { return locationID; }    ///< Returns the location ID of the control unit
        double get_mean_annual_MU_el_demand_kWh() const; ///< Returns the mean electricity demand in kWh of all connected MUs over all available years
        double get_sim_comp_pv_kWp(); // returns the kWp of the PV-component that is added for the simulation, returns 0 if there is no added PV component
        double get_sim_comp_bs_P_kW(); // returns the power in kW of the battery storage component that is added for the simulation, returns 0 if there is no added battery
        double get_sim_comp_bs_E_kWh(); // returns the capacity in kWh of the battery storage component that is added for the simulation, returns 0 if there is no added battery
        float get_annual_heat_demand_th_kWh();  ///< Returns the annual heat demand in (thermal) kWh of all attachted buildings
        float get_annual_hp_el_cons_kWh();      ///< Returns the annual HP electricity consumption of a heat pump in kWh, if it would be added simulatively (regardless whether it is added or not)
        double get_sim_comp_cs_max_P_kW() const; ///< Returns the maximum available charging power of the simulatively added charging station (if the station is enabled; otherwise it returns 0)
        size_t get_sim_comp_cs_n_EVs() const;   ///< Returns the number of connected EVs if the charging station component is enabled, otherwise 0 is returned.
        size_t get_sim_comp_cs_possible_n_EVs() const; ///< Returns the number of EVs that would be connected to the charging station component, if it would be enablede
        double  get_SSR(); ///< Returns the SSR of the CU from the start of the simulation run until the time of function call; most usefull at the end of a simulation run
        double  get_SCR(); ///< Returns the SCR of the CU from the start of the simulation run until the time of function call; most usefull at the end of a simulation run
        double  get_NPV(); ///< Returns the net present value (NPV) of the CU from the start of the simulation run until the time of function call; most usefull at the end of a simulation run
        string* get_metrics_string_annual(); // call this function only if simulation run is finished! It will the compute sums of flows,SSC,SSR and output this as a string
        string* get_metrics_string_weekly_wr(unsigned long week_number); // This function outputs the weekly metrics AND resets the internal weekly counters!
        string* get_pv_section_string(); // This function returns a string containing information about the sections of the sim. added PV component. If no PV component is added, it returns an empty string.
        const ComponentBS* get_component_BS() const { if (has_sim_bs) return sim_comp_bs; else return nullptr; } ///< Returns a pointer to battery storage component, or nullptr if no such component is added.
        const ComponentHP* get_component_HP() const { if (has_sim_hp) return sim_comp_hp; else return nullptr; } ///< Returns a pointer to heat pump component, or nullptr if no such component is added.
        const ComponentCS* get_component_CS() const { if (has_sim_cs) return sim_comp_cs; else return nullptr; } ///< Returns a pointer to EV charging station component, or nullptr if no such component is added.
        const ComponentPV* get_component_PV() const { if (has_sim_pv) return sim_comp_pv; else return nullptr; } ///< Returns a pointer to PV component, or nullptr if no such component is added.
        // public members
        bool is_sim_expanded; ///< Puplicly accessible member, weather the control unit is expanded or not (required for SAC Planning). This flag has no internal effect inside the class.
        // modifiers
        void add_exp_pv();
        void add_exp_bs(); ///< Adds a simulated battery storage. Mind: MUST be called after ControlUnit::add_exp_hp() if it is called to ensure proper storage sizing for all configurations.
        void add_exp_hp();
        void add_exp_cs(); ///< Activates / enables the EV charging station at the control unit
        void add_ev(unsigned long carID); ///< Adds an EV to the charging station (regardless if the charging station is enabled or not)
        void preprocess_ev_data(); ///< Preprocesses EV data, calls EVFSM::preprocessTourInformation() for all attached EVs. Call this method only once right before the first simulation run.
        void set_output_object(CUOutput* output_obj);
        void set_exp_pv_params_A(float kWp_static); ///< Set the kWp of expanded PV installations in the case of static kWp computation per section
        void set_exp_pv_params_B(float kWp_per_m2, float min_kWp_sec, float max_kWp_sec, float max_kWp_unit); ///< Set the kWp of expanded PV installations in the case of dynamic kWp computation per section
        void set_exp_bs_maxE_kWh(float value);
        void set_exp_bs_maxP_kW (float value);
        void set_exp_bs_E_P_ratio(float value); //< Set the E:P-ratio for simulatively added BS components to @param value
        void remove_sim_added_pv(); ///< Removes a simulatively added PV installation
        void remove_sim_added_bs(); ///< Removes a simulatively added battery storage
        void remove_sim_added_components(); ///< Remove all components that are added simulatively
        void reset_internal_state(); ///< Resets the internal state of the object, without removing added components
        // for simulation runs
        bool compute_next_value(unsigned long ts); ///< Computes the value for the (next) time step. The parameter 'ts' defines the current time step (starting counting at 1). This method must be called with strictly consecutive values ​​of parameter 'ts'.
        /**
         * Returns the summarized load at all connected smart meters at a given time step in kW.
         * If there is no data available, it returns 0.0.
         * This method does not change the object.
         * The results equals to get_rsm_demand_at_ts(ts) - get_rsm_feedin_at_ts(ts)
         * @param ts: The time step for which the load should be computed
         * @see get_rsm_demand_at_ts(), get_rsm_feedin_at_ts()
         */
        float get_rsm_load_at_ts(unsigned long ts) const;
         /**
         * Returns the summarized demand at all connected smart meters at a given time step in kW.
         * In contrast to ControlUnit::get_rsm_load_at_ts(), it ignores feed-in.
         * If there is no data available, it returns 0.0.
         * This method does not change the object.
         * @param ts: The time step for which the load should be computed
         * @see get_current_ts_rsm_value(), get_rsm_feedin_at_ts()
         */
        float get_rsm_demand_at_ts(unsigned long ts) const;
        /**
         * Returns the summarized feed-in at all connected smart meters at a given time step in kW.
         * In contrast to ControlUnit::get_rsm_load_at_ts(), it ignores the demand.
         * If there is no data available, it returns 0.0.
         * This method does not change the object.
         * @return only positive numbers (for a feedin - in contrast to get_rsm_load_at_ts()), or 0.0
         * @param ts: The time step for which the load should be computed
         * @see get_current_ts_rsm_value(), get_rsm_demand_at_ts()
         */
        float get_rsm_feedin_at_ts(unsigned long ts) const;

#ifdef PYTHON_MODULE
        void send_control_commands_from_py_interface(double p_bs_kW, double p_hp_kW, const std::vector<double>& p_ev_kW); ///< Send the commands from the python interface for this control unit for the next step to the given control unit. The commands will be processed (i.e., forewarded to the components) in the next call of ControlUnit::compute_next_value(). The ordering of @param p_ev_kW must be the same as the EVs were added to the control unit.
#endif
        //
        // static functions
        // 1. Initializers and destructors
        static void InitializeStaticVariables(unsigned long n_CUs);
        static void VacuumInstancesAndStaticVariables();
        // 2. getter functions
        static ControlUnit* GetInstancePublicID(unsigned long unitID);   ///< Returns instance with a public unitID. Returns NULL, if unitID is out of the given range
        static ControlUnit* GetInstancePublicIDWE(unsigned long unitID); ///< Returns instance with a public unitID. Throws an error, if untiID is not defined
        static ControlUnit* GetInstanceInternalID(unsigned long internalID) {return st__cu_list[internalID];} ///< Returns the instance with a given internal ID without checking of the boundaries
        //static ControlUnit* GetInstanceAtLocationID(unsigned long locationID);
        static const std::vector<ControlUnit*>& GetArrayOfInstances() {return st__cu_list;}
        static size_t GetNumberOfInstances() {return st__n_CUs;}
        static size_t GetNumberOfCUsWithSimCompPV();        ///< Returns the number of control units that hold a simulatively added PV installation
        static size_t GetNumberOfCUsWithSimCompHP();        ///< Returns the number of control units that hold a simulatively added heat pump
        static size_t GetNumberOfCUsWithSimCompEV();        ///< Returns the number of control units that hold a simulatively added (private) EV charging stations
        static double GetAllSimCompBatteriesCharge_kWh();   ///< Returns the charge of all simulatively added battery storage systems at the current ts
        static double GetAllSimCompBatteriesCapacity_kWh(); ///< Returns the capacity of all simulatively added battery storage systems
        static unsigned long GetTotalNumberOfOptimizationCalls()  { return optimization_call_counter; } ///< Returns the total number of calls of an optimizer up to now
        static unsigned long GetCurrentNumberOfOptiVars()         { return n_curr_optimization_vars;  } ///< Returns the current number of variables used in the currently running (parallel) optimizations. Only set if program option 'max-parallel-opti-vars' is set, i.e., Global::get_max_parallel_opti_vars() > 0.
        // 3. modifiers for all created objects
        static void PreprocessEVData(); ///< Preprocesses EV data (min/max consumption until a given ts, states, ...) for all EVs
        static void ResetAllInternalStates();
        static void RemoveAllSimAddedComponents(); ///< Removes all simulatively added components from all control units
        static void ChangeControlHorizonInTS(unsigned int new_horizon); ///< Sets the optimization horizon (if another value is whished than given by Global::get_control_horizon_in_ts()). See also `ControlUnit::change_control_horizon_in_ts()`.
    protected:
        void change_control_horizon_in_ts(unsigned int new_horizon); ///< Sets the optimization horizon (if another value is whished than given by Global::get_control_horizon_in_ts()). This is protected, as the default vector used for the optimization-based control stretegies must be updated, too.
    private:
        // constant member variables (other languages might call this 'final')
        const unsigned long internal_id; ///< The internal ID of the control unit, must be sequentially
        const unsigned long unitID; ///< The public ID as given in the system structure database
        Substation *const higher_level_subst;
        const unsigned long locationID;
        const bool residential; ///< is this control unit representing a residential unit?
        const bool generate_output_for_this_unit; ///< Should an output be generated for this concrete unit?
        // member variables that can change over time
        std::list<MeasurementUnit*>* connected_units;
        bool has_sim_pv; ///< boolean variable that states if a PV installation is simulatively added
        bool has_sim_bs; ///< boolean variable that states if a battery storage is simulatively added
        bool has_sim_hp; ///< boolean variable that states if a heat pump is simulatively added
        bool has_sim_cs; ///< boolean variable that states if an EV charging station is simulatively added
        ComponentPV* sim_comp_pv; ///< Reference to the simulated PV-Component (if it exists)
        ComponentBS* sim_comp_bs; ///< Reference to the simulated battery storage component (if it exists)
        ComponentHP* sim_comp_hp; ///< Reference to the simulated Heat Pump Component (if it exists)
        ComponentCS* sim_comp_cs; ///< Reference to the simulated EV charging station Component (if it exists)
        CUOutput*    output_obj;
        BaseOptimizedController* optimized_controller; ///< Reference to the controller (except of rule-based control)
#ifdef PYTHON_MODULE
        bool py_control_commands_obtained;
        double py_cmd_p_bs_kW;
        double py_cmd_p_hp_kW;
        std::vector<double> py_cmd_p_ev_kW;
#endif
        // summation variables from the beginning of the simulation run until the current time step
        double sum_of_consumption_kWh;    ///< The sum of consumed energy in kWh starting from the beginning of the current simulation run
        double sum_of_self_cons_kWh;      ///< The sum of self-consumed energy in kWh starting from the beginning of the current simulation run
        double sum_of_mu_cons_kWh;        ///< The sum of energy consumed by measurement units from the beginning fo the simulation until the current step
        double sum_of_feed_into_grid_kWh; ///< The sum of energy in kWh, that is fed into the grid, starting from the beginning of the current simulation run
        double sum_of_grid_demand_kWh;    ///< The sum of energy in kWh, that is taken from the grid, starting from the beginning of the current simulation run
        double sum_of_rem_pow_costs_EUR;  ///< The sum of the costs for the (remaining) demanded energy starting from the beginning of the current simulation run up to the current step
        double sum_of_saved_pow_costs_EUR;///< The sum of saved power costs, i.e., the sum avoided grid demand starting from the beginning of the current simulation run up to the current step
        double sum_of_feedin_revenue_EUR; ///< The sum of the costs for the demanded energy starting from the beginning of the current simulation run up to the current step
        double sum_of_emissions_cbgd_kg_CO2eq;///< The sum of emissions in kg CO2eq. caused by grid demand (thus _bgd_ in the variable name) starting from the beginning of the current simulation run up to the current step
        double sum_of_emissions_avoi_kg_CO2eq;///< The sum of avoided emissions in kg CO2eq. because no grid demand was required starting from the beginning of the current simulation run up to the current step
        unsigned long sum_of_errors_in_cntrl; ///< The number of errors happend in the controller / optimization until the current time step
        unsigned long sum_of_errors_in_cntrl_cmd_appl; ///< The number of errors happend during the application of control commands in the component heat pump or EVFSM until the current time step
        // other variables that are valid from the beginning of the simulation run until the current time step
        double peak_grid_demand_kW;             ///< The maximum of grid demand that occured during a time step
        // summation variables from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_consumption_kWh;    ///< The sum of consumed energy in kWh starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_self_cons_kWh;      ///< The sum of self-consumed energy in kWh starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_mu_cons_kWh;        ///< The sum of energy consumed by measurement units from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_feed_into_grid_kWh; ///< The sum of energy in kWh, that is fed into the grid, starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_grid_demand_kWh;    ///< The sum of energy in kWh, that is taken from the grid, starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_rem_pow_costs_EUR;  ///< The sum of the costs for the (remaining) demanded energy starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_saved_pow_costs_EUR;///< The sum of saved power costs, i.e., the sum avoided grid demand starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_feedin_revenue_EUR; ///< The sum of the costs for the demanded energy starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_emissions_cbgd_kg_CO2eq;///< The sum of emissions in kg CO2eq. caused by grid demand (thus _bgd_ in the variable name) starting from the beginning of the currently simulated week until the current time step
        double sum_of_cweek_emissions_avoi_kg_CO2eq;///< The sum of avoided emissions in kg CO2eq. because no grid demand was required starting from the beginning of the currently simulated week until the current time step
        unsigned long sum_of_cweek_errors_in_cntrl; ///< The number of errors happend in the controller / optimization until the current time step
        unsigned long sum_of_cweek_errors_in_cntrl_cmd_appl; ///< The number of errors happend during the application of control commands in the component heat pump or EVFSM until the current time step
        // other variables that are valid from the beginning of the currently simulated week until the current time step
        double cweek_peak_grid_demand_kW;       ///< The maximum of grid demand that occured during a time step in the current week
        // caches for optimization
        unsigned long ts_since_last_opti_run; ///< Number of time steps since the last optimization run
        //bool   create_history_output; ///< True, if a history output should be created for this control unit.
        // Internal storage variables for the current state, especially the current power flows
        double current_load_vSM_kW; ///< Current load at the virtual smart meter
        double self_produced_load_kW; ///< Load [in kW] that is produced by the PV / taken from Battery / El. vehicle AND directly consumed by the measurement units
        double current_total_consumption_kW; ///< Current total electricity consumption
        double current_PV_feedin_to_grid_kW; ///< If `current_load_vSM_kW < 0` --> kW of the grid feed-in generated by the PV
        double current_BS_feedin_to_grid_kW; ///< If `current_load_vSM_kW < 0` --> kW of the grid feed-in generated by the battery storage system
        double current_CHP_feedin_to_grid_kW; ///< If `current_load_vSM_kW < 0` --> kW of the grid feed-in generated by a CHP
        double current_wind_feedin_to_grid_kW; ///< If `current_load_vSM_kW < 0` --> kW of the grid feed-in generated by a wind turbine
        double current_unknown_feedin_to_grid_kW; ///< If `current_load_vSM_kW < 0` --> kW of the grid feed-in generated by a unknown sources (or not attributable ones)
        //
        bool is_expandable_with_pv_cache; ///< Cached value saying is this unit expandable with a (roof-top) PV installation or a heat pump (it requires geo data for this!)
        bool is_expandable_with_pv_cache_computed; ///< Boolean variable if cache has been computed
        bool is_expandable_with_hp_cache; ///< Cached value saying is this unit expandable with a (roof-top) PV installation or a heat pump (it requires geo data for this!)
        bool is_expandable_with_hp_cache_computed; ///< Boolean variable if cache has been computed
        //
        // Variables required for multi-threading
        // CUControllerWorkerThread is getting full access to the member variables of this class
        // Required only for the member variable worker_thread
        friend class CUControllerWorkerThread;
        CUControllerWorkerThread* worker_thread; ///< The working thead to which this substation is attached. The reference is NULL if unattached or no multithreading is used.
        //
        // static list of CUs
        static unsigned long st__n_CUs;
        static std::vector<ControlUnit*> st__cu_list;
        static std::map<unsigned long, unsigned long> public_to_internal_id;
        static std::vector<double>* st__empty_vector_for_time_horizon; ///< An vector of 0.0 with the size of the current control horizon
        //static std::map<unsigned long, ControlUnit*> location_to_cu_map;
        // other static members
        static std::atomic<unsigned long> optimization_call_counter; ///< atomic variable of global number of optimization calls
        static std::atomic<unsigned long> n_curr_optimization_vars; ///< The number of optimization variables in the currently running parallel optimization threads
        static std::mutex n_curr_optimization_vars_mutex;
        static std::condition_variable curr_opti_cv; ///< Condition variable for the parallel optimization to limit the number of parallel optimization calls based on the number of variables
    public:
        static const std::string MetricsStringHeaderAnnual; ///< The header for the output string produced by `ControlUnit::get_metrics_string_annual()`
        static const std::string MetricsStringHeaderWeekly; ///< The header for the output string produced by `ControlUnit::get_metrics_string_weekly_wr()`
};


/*!
 *  The measurement unit represents an existing unit, which is measured by an existing
 *  smart meter where we have real measured data for.
 *  If there exist additional components, like PV, in reality, an instance of this class knows this.
 */
class MeasurementUnit : BaseUnit<MeasurementUnit> {
    public:
        /*!
         * Instantiates a new measurement unit.
         * Returns false, if the meUID is already defined.
         */
        static bool InstantiateNewMeasurementUnit(size_t meUID, size_t public_unitID, std::string * meterPointName, size_t locID, 
                bool has_demand, bool has_feedin, bool has_pv_resid, bool has_pv_opens,
                bool has_bess,   bool has_hp,     bool has_wind,     bool has_evchst,
                bool has_chp, const std::string& data_source_path);
    private:
        // initialization and destruction
        MeasurementUnit(size_t internalID, size_t meUID, size_t public_unitID, std::string * meterPointName, size_t locID, 
                        bool has_demand, bool has_feedin, bool has_pv_resid, bool has_pv_opens,
                        bool has_bess,   bool has_hp,     bool has_wind,     bool has_evchst,
                        bool has_chp, const std::string& data_source_path);
    public:
        ~MeasurementUnit();
        const std::string * get_meterPointName() const { return meterPointName; } ///< Returns the name of the meter point
        unsigned long get_internal_id()          const { return internal_id; }    ///< Returns the (consecutive) internal ID of the measurement unit
        unsigned long get_meUID()                const { return meUID; }          ///< Returns the ID as given in the system structe database
        unsigned long get_locationID()           const { return locationID; }     ///< Returns the ID of the location
        bool load_data(); ///< Load the data as given by the member variable data_source_path. Returns false if an error happend during file loading.
        bool has_demand() const { return rsm_has_demand; }
        bool has_feedin() const { return rsm_has_feedin; }
        bool has_pv()     const { return rsm_with_pv_residential || rsm_with_pv_open_space; }
        bool has_pv_residential() const { return rsm_with_pv_residential; }
        bool has_pv_open_space()  const { return rsm_with_pv_open_space; }
        bool has_bs()     const { return rsm_with_bess;}
        bool has_hp()     const { return rsm_with_hp;  }
        bool has_evchst() const { return rsm_with_evchst;  }
        bool has_chp()    const { return rsm_with_chp; }
        bool has_wind()   const { return rsm_with_wind;}
        int  get_expansion_combination() const  { return expansion_combination; }
        // for simulation runs
        double get_total_demand_kWh() const; ///< Returns the total demand of the measurement unit over the complete time span of data
        bool compute_next_value(unsigned long ts);
        float get_current_ts_rsm_value() const { return current_load_rsm_kW; }
        /**
         * Returns the load at the smart meter at a given time step in kW.
         * If there is no data available, it returns 0.0.
         * This method does not change the object.
         * The results equals to get_rsm_demand_at_ts(ts) - get_rsm_feedin_at_ts(ts)
         * @param ts: The time step for which the load should be computed
         * @see get_rsm_demand_at_ts(), get_rsm_feedin_at_ts()
         */
        float get_rsm_load_at_ts(unsigned long ts) const;
        /**
         * Returns the demand at the smart meter at a given time step in kW.
         * In contrast to MeasurementUnit::get_rsm_load_at_ts(), it ignores feed-in.
         * If there is no data available, it returns 0.0.
         * This method does not change the object.
         * @param ts: The time step for which the load should be computed
         * @see get_current_ts_rsm_value(), get_rsm_feedin_at_ts()
         */
        float get_rsm_demand_at_ts(unsigned long ts) const;
        /**
         * Returns the feed-in at the smart meter at a given time step in kW.
         * In contrast to MeasurementUnit::get_rsm_load_at_ts(), it ignores the demand.
         * If there is no data available, it returns 0.0.
         * This method does not change the object.
         * @return only positive numbers (for a feedin - in contrast to get_rsm_load_at_ts()), or 0.0
         * @param ts: The time step for which the load should be computed
         * @see get_current_ts_rsm_value(), get_rsm_demand_at_ts()
         */
        float get_rsm_feedin_at_ts(unsigned long ts) const;
        //
        // Class (i.e. static) functions
        // 1. Initializers and destructors
        static void InitializeStaticVariables(unsigned long n_MUs);
        static void VacuumInstancesAndStaticVariables();
        static size_t GetNumberOfInstances() {return st__n_MUs;}
        static bool LoadDataForAllInstances(); ///< Loads the data for all created instances
        //
        // 2. Class getter methods
        static MeasurementUnit* GetInstancePublicID(unsigned long meUID); ///< Returns instance with public id meUID (or NULL, if the ID is not available)
    private:
        // constant member variables (other languages might call this 'final')
        const unsigned long internal_id; ///< The internal ID, must be sequentially
        const unsigned long meUID;  ///< The public ID as given in the system structure database
        ControlUnit *const higher_level_cu;
        const std::string *const meterPointName;
        const unsigned long locationID;
        const std::string data_source_path;
        // member variables that can change over time
        float current_load_rsm_kW;
        bool rsm_has_demand; ///< RSM stands for Real Smart Meter
        bool rsm_has_feedin;
        bool rsm_with_pv_residential;
        bool rsm_with_pv_open_space;
        bool rsm_with_bess;
        bool rsm_with_hp;
        bool rsm_with_evchst; ///< True, if an EV charging station is connected
        bool rsm_with_wind;   ///< True, if a wind farm is connected
        bool rsm_with_chp;
        int expansion_combination;
        // member variables storing the data
        bool   data_loaded;
        int*   data_timestepID;
        float* data_value_demand;
        float* data_value_feedin;
        //char*  data_status_demand;
        //char*  data_status_feedin;
        //
        // static list of MUs
        static size_t st__n_MUs;
        static std::vector<MeasurementUnit*> st__mu_list;
        static std::map<unsigned long, unsigned long> public_to_internal_id;
};



enum OpenSpacePVOrWindType {
    PV,
    Wind
};

class OpenSpacePVOrWind {
    public:
        OpenSpacePVOrWind(float kWp, OpenSpacePVOrWindType type);
        float get_current_feedin_kW() { return current_feedin_kW; }
        // for simulation runs
        bool compute_next_value(unsigned long ts);
    private:
        // constant member variables
        const float kWp;
        const float* profile_data; ///< Reference to the array of size Global::get_n_timesteps(), where the profile is stored. Should be global::wind_profile or global::pv_profile
        // members that might change during the time
        float current_feedin_kW;
};

#endif

